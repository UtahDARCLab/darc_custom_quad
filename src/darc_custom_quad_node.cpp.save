// This file has been created to try and fly the quadcopter using the joystick

#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/Joy.h>
#include <mavros_msgs/RCIn.h>
#include <mavros_msgs/OverrideRCIn.h>
#include <std_srvs/Empty.h>
#include <iostream>

int min_range = 1100, max_range = 1900;
int roll, pitch, yaw, thrust = min_range;
void twist_callback(const geometry_msgs::Twist& twist_msg_in) { //this also scales the joystick reading
  roll   = max_range - 0.5 * (max_range - min_range) * (1.0 + twist_msg_in.angular.x);  // Roll -- rotation about the x axis 
  pitch  = max_range - 0.5 * (max_range - min_range) * (1.0 + twist_msg_in.angular.y);  // Pitch --rotation about the y axis
  yaw    = max_range - 0.5 * (max_range - min_range) * (1.0 + twist_msg_in.angular.z);  // Yaw -- rotation about the z axis
  thrust = min_range + (max_range - min_range) * twist_msg_in.linear.z;  // Thrust
}

mavros_msgs::RCIn rc_in;
void rc_callback(const mavros_msgs::RCIn& rc_msg_in) {
  rc_in = rc_msg_in;
  std::cout << rc_in.channels[0] << std::endl;
}

int main(int argc, char** argv) {
  ros::init(argc, argv, "darc_custom_quad_node");
  ros::NodeHandle node;
  ros::Rate loop_rate(50);

  ros::Subscriber twist_sub;
  //twist_sub = node.subscribe("new_u",1,twist_callback);
  twist_sub = node.subscribe("desired_u",1,twist_callback);

  ros::Subscriber rc_sub;
  rc_sub = node.subscribe("/mavros/rc/in", 1, rc_callback);

  ros::Publisher rc_pub;
  rc_pub = node.advertise<mavros_msgs::OverrideRCIN>("/mavros/rc/override",1);
  mavros_msgs::OverrideRCIn rc_out;

  while (ros::ok()) {
    ros::spinOnce();
    if (rc_in.channels[4] > 1250) {
      rc_out.channels[0] = 0;
      rc_out.channels[1] = 0;
      rc_out.channels[2] = 0;
      rc_out.channels[3] = 0;
    } else {
      rc_out.channels[0] = 1500; //roll;
      rc_out.channels[1] = 1600; //pitch;
      rc_out.channels[2] = 1700; //thrust;
      rc_out.channels[3] = 1800; //yaw;
    }
    rc_pub.publish(rc_out);
    loop_rate.sleep();
  }
  return 0;
}


